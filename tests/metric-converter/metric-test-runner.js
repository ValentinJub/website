/*
*
*
*
*
*
*
*
*
*
*
*
*       DO NOT EDIT THIS FILE
*       For FCC testing purposes!
*
*
*
*
*
*
*
*
*
*
*
*/

const analyser = require('./assertion-analyser');
const EventEmitter = require('events').EventEmitter;

const Mocha = require('mocha'),
    fs = require('fs'),
    path = require('path');

function initialiseMocha() {
  let mocha = new Mocha();
  mocha._cleanReferencesAfterRun = false;
  let testDir = __dirname + '/tests';

  // Add each .js file to the mocha instance
  fs.readdirSync(testDir).filter(function(file){
      // Only keep the .js files
      return file.substr(-3) === '.js';

  }).forEach(function(file){
      mocha.addFile(
          path.join(testDir, file)
      );
  });
  return mocha;
};

function createEmitter() {
  const emitter = new EventEmitter();
  let mocha = initialiseMocha();
  let showTest = [];
  let tests = [];

  emitter.log = function() {
    return showTest;
  };

  emitter.run = function() {
    tests = [];
    let context = "";
    let separator = ' -> ';

    // Run the tests.
    try {
      // Reset the tests array before each run
      let runner = mocha.ui('tdd').run()
        .on('start', function() {
          emitter.emit('start');
        })
        .on('test end', function(test) {
          // remove comments
          let body = test.body.replace(/\/\/.*\n|\/\*.*\*\//g, '');
          // collapse spaces
          body = body.replace(/\s+/g,' ');
          let obj = {
            title: test.title,
            context: context.slice(0, -separator.length),
            state: test.state,
            // body: body,
            assertions: analyser(body)
          };
          tests.push(obj);
        })
        .on('end', function() {
          showTest = [...tests];
          emitter.report = tests;
          emitter.emit('done', tests)
          // required to clear the test files from the require cache 
          // allows repeat test suites to be run in the same session
          mocha.unloadFiles();
        })
        .on('suite', function(s) {
          context += (s.title + separator);
        })
        .on('suite end', function(s) {
          context = context.slice(0, -(s.title.length + separator.length))
        })
    } catch(e) {
      throw(e);
    }
  };

  return emitter;
}

module.exports = createEmitter; 

// let emitter = new EventEmitter();
// emitter.run = function() {

//   let tests = [];
//   let context = "";
//   let separator = ' -> ';
//   // Run the tests.
//   try {
//     // Reset the tests array before each run
//   let runner = mocha.ui('tdd').run()
//     .on('start' , function() {
//     emitter.emit('start');
//    })
//     .on('test end', function(test) {
//         // remove comments
//         let body = test.body.replace(/\/\/.*\n|\/\*.*\*\//g, '');
//         // collapse spaces
//         body = body.replace(/\s+/g,' ');
//         let obj = {
//           title: test.title,
//           context: context.slice(0, -separator.length),
//           state: test.state,
//           // body: body,
//           assertions: analyser(body)
//         };
//         tests.push(obj);
//     })
//     .on('end', function() {
//         emitter.report = tests;
//         emitter.emit('done', tests)
//         mocha.unloadFiles();
//     })
//     .on('suite', function(s) {
//       context += (s.title + separator);

//     })
//     .on('suite end', function(s) {
//       context = context.slice(0, -(s.title.length + separator.length))
//     })
//   } catch(e) {
//     throw(e);
//   }
// };

// module.exports = emitter;

/*
 * Mocha.runner Events:
 * can be used to build a better custom report
 *
 *   - `start`  execution started
 *   - `end`  execution complete
 *   - `suite`  (suite) test suite execution started
 *   - `suite end`  (suite) all tests (and sub-suites) have finished
 *   - `test`  (test) test execution started
 *   - `test end`  (test) test completed
 *   - `hook`  (hook) hook execution started
 *   - `hook end`  (hook) hook complete
 *   - `pass`  (test) test passed
 *   - `fail`  (test, err) test failed
 *   - `pending`  (test) test pending
 */